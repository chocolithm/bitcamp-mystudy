휴가: 5층 행정데스크 방문신청
wifi: Aipalm202_2G / aipalm_202
웨일온: 210 866 3081 / 111222
엄진영 강사님: jinyoung.eom@gmail.com
Git: https://github.com/eomjinyoung/bitcamp-study



# 2024-05-24(금)
  ## CPU가 RAM에서 명령과 데이터를 받아 처리, 이때 명령과 데이터를 S/W로 칭함

  ## S/W는 System S/W와 Application S/W로 구분
  - System S/W: H/W 제어 (OS, 드라이버, 임베디드, IoT 등)
  - Application S/W
    > Standalone: 외부 S/W의 도움 없이 실행 (MS Office, Photoshop 등)
    > Client/Server: 외부 S/W와 통신 필요 (카카오톡, 메일 등)
       설치형과 비설치형으로 세부 구분되며, 그 중 비설치형인 Web Application이 수업목표

  ## Web Application
  - 웹브라우저가 웹서버로부터 HTML, CSS, JS, images 등을 내부적으로 다운받아 실행
  - 정적 파일을 그냥 다운받을 수도 있지만, java 등을 통해 동적으로 작성하여 다운받을 수 있음

  ## CLI: Command Line Interface / 글자를 이용하여 명령을 내리는 방식


# 2024-05-27(월)
  ## GIT: 소프트웨어 형상관리 시스템 (S/W Configuration Management System / SCM)
  - 버전관리라고도 칭하는데, 버전이란 변경에 대해 번호를 부여하는 것
  - clone. add, commit, push, pull
  - .gitignore을 활용하여 백업대상에서 특정파일 제외 가능
  - 초기 commit 시 email, username 설정 필요 / 초기 push 시 username, password 설정
    github에서 access token 발행하여 사용

  ## Virtual Box와 Vagrant 사용하여 가상 OS 띄우기

  ## CPU, 기계어, OS의 관계
  - CPU는 동일하지만 OS가 다를 경우, 각 OS마다 요구하는 포맷이 다르기 때문에 각각의 OS에 맞추어 컴파일 필요
  - OS는 동일하지만 CPU가 다를 경우에도 각각의 CPU마다 별도 컴파일 필요


# 2024-05-28(화)
  ## 애플리케이션 개발 방식
  - 컴파일 : 소스코드 -> (컴파일) -> 기계어 -> (실행) -> OS
  - 인터프리트 : 소스코드 -> (로드) -> 인터프리터 -> (실행) -> OS
  - 하이브리드 : 자바의 경우 소스코드를 클래스로 컴파일한 후, JVM을 통해 인터프리트 방식으로 실행

  > 컴파일 방식은 OS에 따라 별도로 컴파일해야 한다는 단점이 있고
     인터프리트 방식은 실행할 때마다 소스파일이 있어야 하고, 매번 문법검사가 진행되어 속도 저하, 실행 전에는 문법 오류를 알 수 없음
  > 하이브리드 방식은 컴파일 시 문법 검사를 하며, 기계어와의 유사함으로 실행 속도가 빠르고 한번의 컴파일로 여러 OS에서 실행 가능

  ## 크롬은 V8 Javascript 엔진, Blink HTML/CSS 렌더링 엔진이 포함되어 있다.
  - Blink 엔진은 Safari에 있는 Webkit HTML/CSS 렌더링 엔진을 개선한 것

JRE (Java Runtime Environment) : JVM + 실행할 때 사용하는 도구
컴파일러, 디버거, 프로파일러, 문서생성기 등 개발관련 도구를 JRE와 합쳐 만든 것이 JDK

Java SE (Standard Edition) : JRE, ServerJRE, JDK
Java EE (Enterprise Edition) : 웹 App. 개발도구, 분산 App. 개발도구, 자원관리도구, 테스트용 서버 등
Java ME (Micro Edition) : Embedded App. 개발도구

  ## EE 실행요건
1. 다중사용자가 이용 -> Servlet, JSP, JSTL, EL, JSF 등 Web App. 제작도구
2. App.의 분산 배치 -> 분산 컴포넌트 제작도구


# 2024-05-29(수)
  ## VSCode Java 포매팅
  - 폰트는 네이버 D2Coding 폰트 사용
  - 저장 시 auto formatting 적용 (구글 기준)
  - code lens 해제, inlay hint 해제

javac -encoding UTF-8 [파일명]
  - 소스파일이 어떤 규칙에 따라 문자를 저장했는지 컴파일러에게 알려줌
javac -d [폴더경로] [파일명]
  - class 파일을 저장할 폴더 지정
java -classpath (-cp) [폴더경로] [파일명]
  - class 파일의 위치를 JVM에게 알려줌
javac -target [버전] [파일명]
  - 컴파일 후 실행할 버전을 지정

  ## jdk-17까지는 Windows에서 한글이 들어간 java 파일을 컴파일하려 하면 오류 발생
  - vscode는 utf-8로 파일을 저장하지만 Windows는 MS949 형식으로 텍스트를 읽기 때문에
    소스파일이 MS949로 저장되었을 거라 추측 -> 컴파일 오류 발생
  - javac 에서 -encoding 옵션으로 해결

  ## 소스파일 폴더와 컴파일 결과파일 폴더 분리
  - 통상 소스파일은 src, 컴파일 결과는 bin 하위에 보관

  ## 개발관리
  - 개발관리의 편의를 위해 각 응용프로그램을 프로젝트로 구분

  ## 프로젝트와 디렉토리
  - 프로젝트별로 src 폴더. bin 폴더 구분
  - src 폴더는 main과 test로 구분, 하위에는 사용언어에 따라 java, kotlin 등으로 구분

  ## Git 저장소와 프로젝트 폴더
  - 통상 저장소 하나당 프로젝트 하나
  - 하나의 저장소에 여러 프로젝트를 둘 경우, 저장소 단위로 버전이 관리되기 때문에
    개별 프로젝트 단위 관리가 어려움
  - 하나의 메인 프로젝트와 여러 서브 프로젝트를 두는 것은 가능

  ## 빌드란?
  - 소스코드를 실행 가능한 소프트웨어로 변환하는 과정
  - 컴파일 -> 링크 -> 테스트 -> 패키징 -> 배포
     API 문서 생성 포함
  - 자바는 빌드도구가 JDK를 통해 컴파일, API 문서생성, 단위테스트, 패키징(Jar) 등을 수행

  Ant : build.xml
  Maven : pom.xml / 의존 라이브러리 관리기능 추가
  Gradle : build.gradle / 빌드 과정을 정교하게 제어할 수 있도록 프로그래밍 언어로 빌드스크립트 작성
              gradle은 maven 호환이기 때문에 의존 라이브러리 저장소 사용 가능

  jar : java archive / 자바 실행과 관련된 파일을 한 파일로 묶은 것
  war : web archive
  tar : tape archive

  DSL : Domain-Specific Language

gradle init
gradle compileJava (컴파일만 수행)
gradle build (-i : info 출력)
gradle clean
gradle run (-q : 결과만 출력)


# 2024-05-30(목)
  ## Java Class 파일은 16진수 바이트코드로 구성
  - sublime 텍스트 에디터를 사용해 HelloWorld.class 직접 작성 체험
  - javap = 클래스파일 분석

  ## 자바 기초 프로그래밍
  - 명령문 -> 함수 -> 클래스 -> 패키지 -> 모듈
  - 라이브러리 : 다른 개발자가 만들어 컴파일해 둔 코드 (.lib, .dll - Windows, .so - Linux, Unix)
  - 로더 : OS가 프로그램 실행 시 기계어를 메모리에 로딩해주고 main()을 호출하는 보조코드
  - C언어는 소스파일을 컴파일한 후 라이브러리와 묶어 실행파일로 linking


# 2024-05-31(금)
  - 어셈블리 한줄은 기계어 한줄과 매핑되기에, 통상 어셈블리 코딩을 기계어 코딩이라 칭함
  - C언어 컴파일 시 gcc는 어셈블리어로 컴파일하고, 어셈블러가 이를 기계어로 컴파일함
  - Java에서는 bytecode viewer에서 보이는 내용이 어셈블리어 역할을 암

  ## 자바 패키지
  - 클래스를 분류하는 문법

  ## 주석
  - /* */ traditional comment와 // end-of-line comment
  - /**  */ 형식으로 주석을 사용하면 javadoc 실행 시 API 문서를 만듦
  * API는 클래스나 메소드의 설명이 담긴 Interface 문서
javadoc -encoding UTF-8 -charset UTF-8 -d docs -sourcepath app/src/main/java com.eomcs.lang.ex02

  ## Annotation
  - 컴파일러나 JVM에게 전달하는 특별한 정보
  - annotation 주석은 .class 파일에 포함될 수 있음

  ## Literal
  - 값을 표현한 것
  - 상세 설명은 pdf 참고
  - 2진수는 0b, 8진수는 0, 16진수는 0x를 맨 앞에 붙여 표기
  - 부동소수점 지수 표기법: 숫자 뒤에 e + 지수


# 2024-06-03(월)

  ## 줄바꿈
  - Linux/Unix : LF만 사용 (0x0A)
  - Windows : CRLF 사용 (0x0D 0x0A)

  ## 문자 집합
  - ISO-8859-1 : ASCII(7비트)에서 1비트를 추가하여 표기 / 한글 표기 불가 (저장 시 ?로 표기)
  - EUC-kR : 2바이트 / 한글 2,350자만 표기 가능 (천리안/하이텔에서 사용)
  - 조합형 : 5비트 초성, 중성, 종성을 조합 / 맨 앞의 1비트가 1이면 한글 / 조합한 후 4비트씩 나누어 표현
                국제표준이 아니며, 16비트의 절반을 한글이 사용하여 타언어 표현이 어려움
                EUC-KR과 호환되지 않음 / 아래아한글에서 사용
  - MS949 : Windows 95부터 EUC-KR 2,350자에 더하여 총 11,172자를 정의
                국제표준이 아니어서 Windows에서만 사용 가능 (Linux/Unix 불가)
  - Unicode : 최대 4바이트 중 21비트를 사용하여 문자를 표기 (0x000000 ~ 0x10FFFF)
                   UTF-16 은 2바이트이며, 자바에서 문자를 다룰 때 사용 (UTF-16 Big Endian 방식)
                   전세계 문자를 새로 지정하였으며, 알파벳도 2byte로 표현한다는 단점이 있어 UTF-8 등장
  - UTF-8 : 비트 패턴에 따라 1바이트부터 4바이트로 문자를 표기
               알파벳은 ASCII 와 동일하게 1바이트로, 한글은 3바이트로 표현
               자바에서 문자열을 저장할 때 사용

  ## 인코딩/디코딩
  - A값을 B값으로 변환(인코딩)하거나 되돌리는(디코딩) 방식
  - 인코더와 디코더를 합쳐 CODEC 이라 칭함

% 인코딩 : URL 내 특정 문자를 안전하게 표시하기 위한 인코딩 방식

  ## 숫자 저장 방식
  - Sign-Magnitude 방식 (부호 절대값) : 부호비트와 절대값 활용 / 부동소수점 가수부 저장 시 사용
  - 1의 보수 : 각 비트의 반대값으로 보수를 구성 / 사용하지 않음
  - 2의 보수 : 1의 보수 + 1 / 정수 저장 시 사용
  - Excess-K : bias 값을 더하여 저장 / bias k = 2^(비트수 - 1) - 1 / 부동소수점의 지수부를 저장할 대 사용
    즉 8비트 기준으로 K값은 2^(8-1) - 1 = 127
    최소값은 127 + (-127) = 0 / 최대값은 127 + 128 = 255이 되어 순차적으로 정렬 가능

  ## 부동소수점 방식 (floating-point)
  - 10진수 값을 IEEE-754에 따라 2진수로 변환
    12.375 변환 시 소수점 뒤의 값은 2를 곱한 값이 1 이상인지를 비교하여 계산
    1100.011을 구한 후 정규화 수행 => 1.100011 * 2^3
    가수부는 100011, 지수부는 excess-k를 적용하여 3 + 127(bias) = 130 = 10000010
    => 32비트 기준, 부호비트 1비트 + 지수부 8비트 10000010 + 가수부 23비트 100011
    => 0100 0001 0100 0110 0000 0000 0000 0000 => 41 46 00 00


# 2024-06-04(화)
  ## 변수 (Variables)
  - 데이터를 저장하는 메모리
  - 변수 선언 : 메모리를 준비시키는 명령

  ## 데이터 타입
  - Primitive Data Types : 정수(byte, short, int, long), 부동소수점(float, double), 논리(boolean), 문자(char)
  - User Defined Data Types : 클래스
  - 역할 : 메모리 사용 제어 / 같은 숫자를 저장하더라도 int냐 float이냐에 따라 저장값은 달라짐
  - byte b = -128 이라고 할 때, -128이라는 정수 리터럴은 4바이트 int값이 기본
    원래 1바이트인 byte 변수에 4바이트를 저장할 수 없지만, 리터럴은 저장할 수 있는 값이라면 컴파일러가 허용함
  - 소수점에 관계 없이 float은 대략 7자리까지, double은 대략 15자리까지 "거의 정확하게" 저장 가능
    이를 유효자릿수라 부르며, 이를 초과하면 값이 일부분만 저장될 가능성이 높음 / 따라 8바이트 사용이 권장됨

  ## 이클립스
  - 이클립스로 프로젝트 import 시 특정 설정파일이 필요 (.project / .classpath 등)
  - build.gradle 에 이클립스 플러그인 설정 가능
  - 설정 후 gradle tasks 를 입력하면 사용가능한 task 확인 가능
  - [File] - Import - Working Directory 선택 후 .project 파일이 있는 폴더 선택


# 2024-06-05(수)
  ## IntelliJ
  - settings.gradle 파일로 프로젝트 오픈
  - Scanner 사용 시, gradle로 실행하면 키보드 표준입력을 받지 못하고 실행이 종료됨
    이 경우 build.gradle에 standardInput으로 System.in 을 받도록 설정해야 함

  ## 해시코드 체크 : certutil -hashfile "대상파일" "알고리즘"

  ## 자바 패키지
  - 패키지명은 조직명, 제품명, 역할명 등으로 구성
    조직명으로 사용할 시 Domain Name을 거꾸로 사용 (com.microsoft / com.bitcamp 등) / 폴더 구분 용이

  ## 마크다운 (README.md)
  - HTML 태그보다 간결한 방식으로 문서 형식을 지정하기 위해 만든 포맷
  - #,   ## 등으로 제목을 표시하며, HTML로 변환 시 각각 h1, h2 등 태그로 변환됨

  ## 리팩토링
  - 의미 있는 변수명 사용하기


# 2024-06-07(금)
  ## 연산자
  - 산술연산자 : +. -. *. /, %
  - 증감연산자 : ++, --
  - 관계연산자 : <, <=, >, >=, instanceof
  - 등가연산자 : ==, !=
  - 논리연산자 : &&, ||, ! (+ boolean에 한해 &, | 를 포함하기도 함)
  - 비트연산자 : &, |, ^, ~
  - 비트이동연산자 : <<. >>, >>>
  - 대입연산자 : =, +=, -=, *=, /=, %=, &=, !=, ^=, <<=, >>=, >>>=
  - 삼항연산자 : 조건 ? 값1 : 값2

  ## 연산 관련 학습
  - 서로 다른 타입의 연산
    -> 연산은 같은 타입만 가능하며, 타입이 다르면 컴파일러가  타입을 맞춘 후 연산을 수행 (imlicit type conversion)
    -> 개발자가 명시적으로 타입을 변환할 수 있다. (explicit type conversion)
    -> 정수는 부동소수점에, 작은 크기의 값은 큰 크기의 값에 타입을 맞춤
         byte. char. short --> int --> long --> float --> double
    -> 형변환 시 값이 잘릴 수 있다는 점 유의
  - 연산의 결과는 항상 int로 변환
    -> 즉, byte 타입의 변수 둘의 연산을 수행하면 그 결과는 int 가 됨
  - 만약 int의 범위를 초과하는 값의 연산을 long 변수에 대입하려 한다면 음수가 출력됨 (오버플로우가 먼저 발생)

  ## Statement & Expression
  - Statement : 어떤 작업을 수행하는 단위
  - Expression : 값을 반환하는 문장


# 2024-06-10(월)
  ## 조건문
  - 자바에는 if ~ else if ~ else 구문이 존재하지 않으며, if ~ else 문을 줄맞춤한 것에 불과
  - switch case 문에서 case 값으로는 리터럴만 가능 / 변수는 컴파일 시 값이 정해지지 않아 불가
    하지만 상수는 가능 (final int GUEST = 0;)  com.eomcs.lang.ex06.Exam0241 참고

  ## 배열
  - 배열의 각 요소에는 메모리의 주소가 저장됨 / 각 요소는 객체 또는 인스턴스라 칭함
  - 배열은 배열 메모리의 주소를 저장하는 변수로서, 레퍼런스라고 칭함
  - 배열의 최대 크기는 Integer.MAX_VALUE - 2 와 같음 (VM Limit)

  ## 배열 레퍼런스와 가비지
  - 메모리 사용량이 일정수준 이상 증가하면, 사용하지 않는 객체를 JVM이 자동 감지하여 제거
  - Reference Counting : 객체의 참조 횟수를 추적하여 0이 되면 제거
  - Reference Tracing : 참조 추적 알고리즘을 사용하여 객체의 참조여부 분석


# 2024-06-11(화)
  ## 인스턴스와 메서드
  - 메서드는 레퍼런스.메서드() 의 형식을 가짐
  - 레퍼런스는 도구(메서드)를 실행하는 데 사용할 기본 데이터가 있는 인스턴스의 주소
  - 괄호는 도구를 실행할 때 사용할 추가 데이터
  - Math.abs() 의 경우, 기본데이터 없이 추가데이터만으로 사용
  - System.our.ptinln()을 예로 들면, out이 인스턴스로서 "콘솔 출력"이라는 기본데이터를 담고
    괄호는 "출력할 내용" 이라는 추가 데이터를 가짐

  ## 입출력
  - System.in (표준 입력), System.out (표준 출력), System.err (표준 오류 출력)
  - 표준 입력은 Scanner 클래스를 활용해 더 쉽게 처리할 수 있음
  - Scanner와 연결된 입력스트림으로 어떤 값을 주느냐에 따라 차이 발생 (System.in / 파일 / 소켓 등)
  - Scanner 인스턴스.next() 메서드는 1개의 토큰을 반환 (공백으로 구분된 문자열)

  ## String
  - 원시타입을 제외한 모든 데이터 타입의 변수는 레퍼런스이며 null 가능 (배열변수 포함)
  - String 리터럴은 별도의 영역에서 관리되며, 이미 만들어진 인스턴스가 있다면 해당 주소를 리턴
    따라 s1 = "aaa"; s2 = "aaa"; s1 == s2 에서 true 가 가능
    new String("aaa") 형식으로 만들면 Heap 에서 별도 관리함


# 2024-06-12(수)
  ## 메서드
  - ReturnType MethodName (Parameter, ...) {     <-- Method Signature
      Method Body
    }
  - 메서드 호출 시 Parameter에 넘겨주는 값을 Argument
  - Parameter는 메서드 안에서만 사용하는 Local 변수이며, 메서드 호출 시 생성, 호출 종료 시 제거
    이를 통해 여러 스레드가 동일 메서드를 호출하더라도 값이 덮어쓰이는 것을 방지할 수 있음
  - main() 실행 시 JVM Stack에 Frame이 생성되고, 메서드를 호출하면 해당 메서드의 Frame 생성

  ## JVM과 스레드
  - JVM이 main() 을 호출하고, 완료될 때까지 이어지는데 이를 실행흐름, Thread 라 칭함
  - 멀티스레드 프로그래밍은 동시에 여러 개의 스레드를 진행하는 것을 의미

  ## 디버그
  - Step Over : 한 줄씩 진행
  - Step Into : 메소드 안으로 들어가며 진행
  - step Return : 해당 메소드를 모두 진행하고 빠져나옴

  ## JVM 메모리 영역
  - Method Area : 클래스 코드, 클래스 필드, 상수 풀 등
  - JVM Stack : Stack Frame (로컬 변수, 메서드 호출 정보 등)
  - Heap : new 명령으로 생성한 인스턴스

  ## Call By Reference / Call By Value
  - Call By Reference : 함수가 인수의 참조주소를 전달받음 / 함수 내에서 값 변경 시 원래 값도 변경
                        함수 내에서 Reference 값을 변경하면 이는 Heap 내에 유지되고,
                        메소드 리턴 후 JVM Stack에서 Frame이 사라져도 Heap 내 값은 변하지 않음
  - Call By Value : 함수가 인수의 값을 전달받음 / 함수 내에서 값이 변경되어도 원래 값은 유지


# 2024-06-13(목)
  - 메서드 프로젝트

# 2024-06-14(금)
  - dll : Dynamic Linking Library
          C는 기본적으로는 모든 파일을 exe로 컴파일하여 한번에 메모리에 올리지만,
          dll을 사용함으로써 당장 필요하지 않은 영역은 메모리에 올리지 않다가 필요할 때 사용
  - Java의 static 변수는 메서드와 같이 Method Area에 올라감

  - 객체지향에서는 A클래스와 B클래스가 쌍방 참조하는 현상을 지양 (유지보수 어려움)
    이는 일부를 별도 클래스로 분리하여 해결 가능


# 2024=06-17(월)
  ## 클래스 문법
  - 클래스는 1. 관련 메서드 분류, 2. 데이터 타입을 정의할 때(user-defined data type) 사용
  - 메서드 분류 목적으로 이용 시, 유지보수가 용이하고 여러 프로그램에서 재사용 가능
    App이 Calculator를 사용할 때, 연관(Association) 관계라 칭함
    메서드를 사용할 변수는 메서드를 관리하는 클래스에서 사용하는 것이 유지보수에 좋음
    ex- Calculator 클래스로 계산이 필요하다면 Calculator.result를 선언하여 사용

  ## static field vs non-static field
  - 클래스 변수(static)는 클래스당 1개만 생성 가능하지만, 인스턴스 변수를 활요함으로써
    여러 계산식을 한꺼번에 사용할 수 있음
    인스턴스 변수는 static이 붙지 않으며, Heap 메모리에 생성됨
    ex- Calculator c1 = new Calculator / c1.result
    * result 변수를 여러 개 유지해야 하는지, 1개만 사용해도 되는지에 따라 static 여부 결정

  ## static method vs non-static method
  - static method 는 인스턴스 주소를 받을 레퍼런스 필요
    static void puls(Calculator that, int a) {that.result = a;}  => Calculator.plus(c1, 100);
  - non-static method는 this를 활용
    this 로컬 변수로 자동 생성되는데, type은 메서드가 소속된 클래스와 동일
    void puls(int a) {this.result = a;}  =>  c1.plus(100);
  - 즉 인스턴스 변수를 사용하는 경우에는 non-static method가 편리함 (레퍼런스를 파라미터로 넘길 필요 X)

  ## 인스턴스
  - Class A { A obj = new A();}
  - 인스턴스 변수가 없더라도, 최소 정보를 담고 있는 인스턴스가 생성됨
  * 메서드의 static 여부를 결정할 때, 인스턴스 사용 여부를 참고하여 결정

  ## 접근제어자 (modifier?)
  - 특정 변수가 값을 대입하는 등 임의조작을 방지하기 위해 private으로 변수 선언 가능
  - 이 때 다른 클래스에서 해당 변수를 가져오기 위해 getter 메서드 사용
  - 타 패키지 내 변수나 메소드에 접근하도록 하기 위해 public 사용
  - private :  클래스 내부 멤버
  - default : private + 같은 패키지 소속 클래스 (= package member)
  - protected : default + 자식클래스
  - public : 모두

  ## User-Defined Data Type
  - Score s1 = new Score()
  - int, String 등 따로 나뉘어 있는 변수들을 Score라는 클래스로 묶어줌

  ## GRASP 패턴 (General Responsibility Assignment Software Pattern)
  - 객체 지향 설계에서 객체의 책임을 할당하는 데 도움을 주는 원칙과 지침의 모음
  - Information Expert : 가장 관련정보를 많이 알고 있는 클래스가 책임을 짐

  ## 패키지
  - 데이터 타입 정의를 위한 클래스는 도메인 || VO || DTO라는 패키지로 분류한다.
  - 패키지를 적을 때에는 최상위 패키지부터 모두 적는다.
  - java.lang 내에 있는 패키지는 import 없이 사용 가능 (java.lang 하위는 import 필요)

  ## 생성자 (Constructor)
  - 인스턴스 생성 후 즉시 자동으로 호출되는 메서드
  - 인스턴스를 사용하기 전에 적절한 값으로 초기화 수행
  - 개발자가 임의로 생성자를 작성하지 않는다면 기본생성자 자동생성
    1개라도 임의로 생성자를 작성했다면 기본생성자 자동생성 X
  - 즉 모든 클래스는 1개 이상의 생성자를 가지고 있다.
  - this()를 통해 다른 생성자를 호출할 수 있다. / 블록 내에서 최상단에 위치해야 한다.
    이 경우 일반 메서드는 this()를 통해 생성자를 호출할 수 없다. (생성자는 인스턴스를 만드는 목적이므로 이미 만들어진 인스턴스에서 수행할 수 없음)


# 2024-06-18(화)
  - 실습 프로젝트 (CRUD 구현)


# 2024-06-19(수)
  ## GRASP 패턴 (General Responsibility Assignment Software Pattern)
  - 객체 지향 설계에서 객체의 책임을 할당하는 데 도움을 주는 원칙과 지침의 모음
  - Information Expert : 가장 관련정보를 많이 알고 있는 클래스가 책임을 짐
  - Low Coupling : 한 모듈이나 구성요소의 변경이 다른 모듈에 영향을 미치지 않도록 함
  - High Cohesion : 모듈 및 클래스 내 요소들이 긴밀하게 연관되어 있음
  - Creator : 특정 클래스가 다른 클래스의 객체를 생성할 책임을 가지는 경우
  - Controller : 시스템의 주요한 이벤트나 작업 흐름을 관리하고 조정하는 역할을 담당하는 클래스나 객체
                 UserCommand, ProjectCommand 등
    
  ## SOLID 방법론
  - SRP / Single Responsibility Principle : 클래스는 하나의 책임만 가져야 하며, 클래스가 변경되는 이유는 하나여야 함
  - OCP / Open/Closed Principle : 클래스, 모듈, 함수 등 개체는 확장에는 열려있지만 변경에는 닫혀야 함 (추상화 / 다형성)
  - LSP / Liskov Substitution Principle : 상위 클래스 객체를 하위 클래스 객체로 대체하여도 정상 동작해야 함 (상속)
  - ISP / Interface Segregation Principle : 클라이언트가 사용하지 않은 메서드에 의존하지 않도록 인터페이스를 분리
  - DIP / Dependency Inversion Principle : 고수준 모듈이 저수준 모듈에 의존해서는 안되며, 추상화를 통해 모듈 간 의존성을 낮춤

  = board.getTtle()을 호출할 때
    기술적으로는 getTitle()이라는 메서드를 호출하여 인스턴스 주소에 접근
    객체지향 개념적으로는 board라는 객체가 title이라는 메시지를 통해 값을 리턴 (객체가 일을 하는 듯한 추상적 표현)

  ## 클래스 선언 위치에 따른 분류
  - 1) 패키지 하위에 선언 = Package Member Class / Top Level Class
       public이 아닌 Package Member Class는 Package Private Class 라 함 (패키지는 private 선언 불가 / public과 default만 가능)
  - 2) 타 클래스 내에 static으로 선언 = Static Nested Class
  - 3) 타 클래스 내에 선언 = Nested Class / Inner Class
  - 4) 메서드 내에 선언 = Nexted Class / Local Class
  - 중첩 클래스가 있는 파일을 컴파일하면, .class 파일은 클래스 블록별로 생성됨


# 2024-06-20(목)
  - 실습 프로젝트 (데이터 식별번호 부여하기 / 인스턴스 목록 코드 분리 - High Cohesion)
    UserCommand가 UI 처리, 데이터 보관 이라는 두 역할을 담당했는데, 데이터 보관을 ArrayList라는 별도 클래스에게 이전

  ## JVM 로딩 순서
  - 클래스를 로드하여 Method Area에 할당
  - 메서드 호출 시 JVM Stack에 프레임 생성 (종료 시 삭제)
  - 객체 인스턴스나 배열을 생성할 때 Heap에 할당 (new 명령을 만날 때마다)

  ## 상속
  - 개를 동물이라 칭하거나 표유류라 칭하는 것을 가능하지만, 동물이나 표유류를 개라고 칭할 수는 없음
    이처럼 하위 클래스의 인스턴스에 상위 클래스 생성자를 사용할 수 있음
    Bycicle 하위에 MotorCycle 클래스가 있을 경우, Bicycle b = new MotorCycle(); 이 가능함 
  - 즉, 상위 클래스의 레퍼런스는 하위 클래스의 인스턴스 주소를 담을 수 있음
    상위 분류명으로 하위분류 객체를 가리킬 수 있음
  - 하위클래스가 상위클래스를 가지는 것이 아니라, 공유받는 것

  ## Object 클래스
  - 클래스 파일을 컴파일하며 자동으로 extends Object 가 붙음
    만약 클래스 파일이 다른 클래스를 상속받는다면, 그 다른 클래스가 Object 클래스를 상속하게 되어 연결됨
    즉 자바의 모든 클래스는 Object 클래스의 자손이다.
  - Generalization : 여러 클래스 파일의 공통코드를 묶어 상위 클래스를 만들고, 이를 하위클래스가 상속받아 사용

  ## 캠슐화 (Encapsulation)
  - 데이터 은닉을 통해 데이터의 무결성 유지
  - 복잡한 로직을 감춰 가독성을 높이고 변경을 용이하게 함


# 2024-06-21(금)
  - 실습 프로젝트 (static 필드 한계 / 상속을 통한 공통코드 분리)
  - static 필드를 사용하게 되면 해당 클래스의 재사용/확장성이 떨어짐
    당장 확장이 필요하지 않더라도, 향후 가능성을 고려해 처음부터 인스턴스 필드/인스턴스 메서드를 활용

  ## 클래스를 복제하여 사용할 때 문제점
  - 코드가 중복되어 변경이 번거로움 / 버그가 발생하거나 기능 추가 시 모든 클래스를 반복적으로 처리해야 함
    따라 유지보수 / 코드 재사용이 힘듦
    => 같은 코드를 사용하되 데이터는 분리해야 함

  ## Object 클래스
  - 자바의 최상위 클래스로, 자바의 모든 클래스는 Object 클래스의 하위 클래스이다.
  - 클래스가 가져야 할 기본 메서드를 정의한다.
  - 주요 메서드
    toString() : 인스턴스의 상태를 문자열로 리턴 / 리턴값 = 클래스명@해시값
    equals() : 인스턴스가 같은지 비교 / 리턴값 true or false
    hashCode() : 인스턴스 식별번호 / 리턴값 hash int
    getClass() : 인스턴스 클래스 정보 / 리턴값 클래스 객체
    clone() : 인스턴스 복제 / 리턴값 복제된 인스턴스 주소

  * User 객체를 담고 있는 Object[] 배열은 User[]로 강제 형변환 할 수 없음 (ClassCaseException)
    Object obj = Object[] 로 받은 후, User user = (User) obj;로 해주어야 함


# 2024-06-24(월)
  ## instanceof 연산자
  - instanceof 연산자를 통해 객체가 특정 클래스에 속하는지 확인할 수 있음
    A instanceof B 일 때, A가 B의 객체라면 true를 반환하며 이 때 B는 Super 클래스를 포함
  
  ## Hash
  - 각 인스턴스마다 부여된 고유 식별자로, 인스턴스가 같은지 검사할 때 사용
  - hashCode() 재정의 없이 사용할 시 무조건 인스턴스마다 새 Hash값 부여

  ## toString()
  - 인스턴스의 현재값을 확인하고 싶을 시, toString()을 오버라이딩하여 사용
  - 오버라이딩 없이 사용하면 패키지명.클래스명@16진수Hash값 을 리턴함
    Fully-Quqlified Class Name + 해시값 / FQCN
  - println이 내부적으로 toString()을 호출한다는 점 참고

  ## equals()
  - 기본적으로는 두 인스턴스가 같은지 비교
  - 내용물을 비교하고 싶다면 toString()과 같이 재정의 필요 (String과 Wrapper 클래스는 오버라이딩 되어있음)

  ## hashCode()
  - 인스턴스가 다르더라도 내부값이 같으면 같은 Hash 값을 리턴하고자 할 때, hashCode()를 오버라이딩해서 사용
  - 가장 간단한 방법은 모든 값을 String으로 이어붙인 후, String 클래스의 hashCode()를 사용하는 것
    String 클래스는 같은 문자열에 대해 같은 Hash 값을 리턴하도록 오버라이딩 되어 있음
  - 보통 값이 같은지를 비교할 때 equals()도 함께 사용하기 때문에, hashCode()는 equals()와 함께 오버라이딩
  - 자동생성 시 Objects.hash() 사용

  ## HashSet
  - Set : 중복값을 저장하지 않는 집합으로, equals()와 hashCode()를 통해 동일여부 판단
  - 값을 저장할 때 hash 값을 계산하여 저장 위치를 알아냄 (hash를 특정 수로 나눈 나머지 기준)
    즉 값을 입력하는 순서를 고려하지 않음
  - 내부적으로 HashMap 사용

  ## HashMap
  - put(key, value)를 사용하여 key와 value 값을 저장
  - key의 해시코드를 사용하여 저장할 위치를 계산 (해시코드가 동일하다면 같은 key로 간주)
  - 값을 찾을 때는 key 객체의 hashCode()와 equals()가 일치하는지 여부로 구분
  - key는 중복될 수 없지만 value는 중복 가능
  - auto-boxing : key 값으로 int를 넘겨주면 컴파일러가 자동으로 Integer 객체를 생성하여 key로 활용
    이는 JVM이 아니라 컴파일러가 수행

  * Set은 고유한 요소를 다루는 데 유용하며, Map은 key를 통해 값을 사용하는 데 유용

  ## getClass()
  - getClass() 메서드와 Class 객체 내 메서드를 활용하여 클래스 정보를 확인할 수 있음
  - Primitive Types는 Object의 서브 클래스가 아니기에 getClass() 호출 불가
    대신 built-in static 변수인 class를 사용할 수 있음
  - 배열에 사용 시 배열 타입과 차원 등 정보를 리턴

  ## clone()
  - 인스턴스를 복제할 때 호출하는 메서드
  - protected로 선언되어 있으며, sub클래스의 경우 *자신의 멤버라면* 접근 가능
    따라 위 제약을 피하기 위해 오버라이딩 후 사용
  - 오버라이딩 시 메서드 코드는 JVM 자동 작성하니, clone 메서드 도입부와 리턴 타입만 작성
  - 인스턴스 복제 기능을 활성화하려면 Cloneable 인터페이스를 구현해야 함
  - Shallow Copy : 모든 필드를 복제하되, 객체가 참조하는 다른 객체는 복제 제외
  - Deep Copy : 포함하고 있는 객체까지도 복제 / 즉 복제한 객체 필드값의 변화가 원 객체에 영향을 주지 않음

  ## 오버라이딩 접근범위 / 리턴타입 규칙
  - 접근범위 : super 클래스보다 접근 범위를 확대할 수는 있지만 축소할 수는 없음
  - 리턴타입 : sub 클래스는 리턴 가능하지만 super 클래스는 불가


# 2024-06-25(화)
  - 실습 프로젝트 (배열 크기 자동 증가시키기 / LinkedList 자료구조 구현)

  ## 다형성
  - SuperClass obj = new SubClass() 라고 가정할 때, obj는 SuperClass이기 때문에 SubClass의 메서드를 사용할 수 없다.
    JVM은 문법만 검사하기 때문에, obj 내부에 무엇이 들어있는지 따지지 않고 obj의 타입인 SuperClass의 메서드를 사용할 것이라 생각한다.
    다만 메서드를 찾을 때에는 Sub -> Super 순으로 찾기 때문에, SubClass에서 오버라이딩한 메서드는 사용할 수 있다.
    SubClass의 메서드를 온전히 사용하고 싶다면 형변환을 해주어야 한다. / SubClass s = (SubClass) obj;

  ## mutable vs immutable
  - mutable은 객체 내 값이 변할 수 있음을 의미하고, immutable은 객체 내 값이 변하지 않음을 의미한다.
    String은 대표적인 immutable 객체이며, StringBuffer, StringBuilder는 mutable 객체이다.

  ## StringBuffer & StringBuilder
  - StringBuffer는 한 작업을 하는 동안 Lock을 걸어 작업이 중복되지 않도록 함
  - StringBuilder는 Lock을 걸지 않아 여러 작업이 동시에 수행될 수 있음 / Lock 설정 및 해제가 없기 때문에 상대적으로 속도가 빠름

  ## 배열과 LinkedList
  - 배열 장점 : 메모리 크기가 고정되어 있어 인덱스를 이용한 접근 용이
  - 배열 단점 : 메모리 크기 변경 불가 / 새 배열 생성 및 복제할 수는 있지만 가비지가 생성됨 / 삽입, 삭제 시 순서 조정에 비용이 들어 속도 저하
  - LinkedList는 메모리 증가나 삽입/삭제가 쉽지만, 데이터 조회 시 시간이 많이 소요된다.
    => 조회 위주로 데이터를 사용한다면 배열을, 삽입 삭제가 자주 일어난다면 LinkedList를 사용하는 편이 좋다.

  - LinkedList : value와 next로 이루어진 node로 구성되는데, next는 다음 값의 주소를 가짐
                 first는 첫 node의 주소를, last는 마지막 node의 주소를 가짐


# 2024-06-26(수)
  - 실습 프로젝트 (인터페이스를 이용한 객체 사용 규칙 정의)

  ## 인터페이스
  - 다양한 클래스들이 공통된 동작을 구현하도록 강제하여, 일관된 API를 제공하고 다형성을 지원
    인터페이스를 구현하는 클래스는 인터페이스 내 모든 메서드를 반드시 구현해야 함
    인터페이스를 추상 클래스가 구현하고, 서브클래스가 추상 클래스를 상속받을 때에도 모든 메서드를 구현해야 함
  - 인터페이스는 참조 타입이기 때문에, 인터페이스로 객체를 생성하고 싶으면 이를 구현한 객체를 대입해야 함 ( Interface i = new Concrete() )
    이 때 대입한 구현 객체에 따라 메서드의 실행 내용이 달라짐 ( Interface i = new Television() / Interface i = new Audio() )
  - UML에서 빈 화살표와 점선으로 표기
  - 기본적으로 public abstract 이기 때문에 생략 가능 / 인터페이스를 구현한 메서드도 public
  - Override가 재정의 또는 추상메서드 구현을 의미하기 때문에 이를 통해 인터페이스에 정의된 메서드를 정상 구현했는지 확인할 수 있음

  ## Abstract Class
  - Concrete 클래스 : 인스턴스를 생성하여 사용할 수 있는 클래스
  - Abstract 클래스 : 서브클래스에게 공통 필드나 메서드를 상속해주는 역할을 하는 클래스 / 인스턴스 생성 불가
                      통상 클래스명이 Abstract로 시작
                      유지보수성을 위해 소스코드를 합치고, 서브 클래스를 만들어 사용하도록 제한하는 문법

  ## equals() 에서 getClass()와 instanceof 방식의 차이
  - getClass()는 상속 관계에 상관없이 클래스를 비교
  - instanceof는 Sub instanceof Super 일 때 true를 리턴

  ## 중첩클래스 (Nested Class)
  - 단순한 기능을 가지고 특정 클래스에서만 쓰이는 클래스가 있다면, 이는 해당 클래스 내로 옮겨 중첩클래스로 사용
  - 외부클래스의 인스턴스를 사용할 경우 non-static 중첩 클래스로 사용하고 (inner class), 사용하지 않을 경우 static 중첩 클래스로 사용


# 2024-06-27(목)
  ## 클래스 멤버
  - 필드(변수)
    > static (클래스 필드)
    > non-static (인스턴스 필드)
  - 메서드
    > static (클래스 메서드)
    > non-static (인스턴스 메서드)
  - 생성자
  - 초기화 블록 (initializer)
    > static
    > instance
  - 중첩 클래스 (nested class)
    > static
    > non-static (inner)

  ## 공유 respository 생성
  - Git Repository 생성
  - local에 git clone
  - gradle init 실행
  - vscode 작업영역에 추가
  - .gitignore 설정
  - 패키지 설정 (main, test)
  - 빈 폴더 readme로 채우기
  - 기본 Test파일 주석처리
  - build.gradle 설정
  - git collaborators 등록


# 2024-06-28(금)
  ## 상속
  - 상속을 이용하지 않고 기존 코드를 변경하면 잘 동작하던 기능에 영향을 줄 수 있음
  - 이를 피하기 위해 기존 클래스를 복사하여 사용하면, 기존 클래스에 잠재적 오류나 변경이 있을 시
    모든 복사클래스를 일일이 찾아야함
  - 상속을 사용하면 기존 코드를 수정하는 순간 자식클래스에 자동 적용


# 2024-07-01(월)
  ## 다형적 변수
  - 여러 타입의 객체를 참조하는 레퍼런스
    X <- A / X <- B <- C 일 때, X obj는 new X(), A(), B(), C() 객체를 모두 가질 수 있다.
    즉 레퍼런스는 자식클래스의 인스턴스 주소를 저장할 수 있다.
  - 자식클래스의 인스턴스는 부모클래스의 인스턴스 변수를 갖는다.
    즉 위 예시에서 obj 변수가 X, B, C의 인스턴스 변수를 갖고 있다면 obj는 new C()에 해당
  - B obj를 사용할 경우, obj는 B, 그리고 B의 부모인 X의 인스턴스 변수를 가져야 함
    따라 B obj = new B(), C()는 가능하지만 new X(), A()는 불가

  ## 다형적 변수의 제약조건
  - Bike b = new Bike() / Vehicle v = b 라고 할 대, b는 v의 자식이므로 컴파일 가능
    하지만 v.bikeMethod()는 컴파일을 통과할 수 없어 사용 불가
    컴파일러는 Vehicle v의 안에 Bike를 가리키는 주소가 있는지 확인하지 않음
  - Car c = new Sedan() 이라고 하면 c는 Vehicle, Car 변수만 사용 가능 (Sedan 변수는 사용불가)
    만약 사용하고자 한다면 ((Sedan)c).sedanMethod() 와 같이 형변환 후 사용해야 함

  ## 오버로딩 (Overloading)
  - 파라미터 타입이나 개수가 다르더라도 동일 기능을 수행하는 메서드는 이름을 동일하게 함으로써
    프로그래밍의 일관성을 제공하는 문법

  ## 오버라이딩 (Overriding)
  - 상속받은 메서드를 서브클래스의 역할에 맞게 재정의하는 문법
    상속받은 메서드와 시그니쳐가 같아야 함(메서드명, 파라미터 타입/개수/순서)
  - 리턴 타입으로 서브클래스를 부여할 수 있음
  - @Override 어노테이션을 통해 점검 가능

  ## this와 super 활용
  - this는 인스턴스가 소속된 클래스부터, super는 메서드가 소속된 클래스의 수퍼클래스부터 찾아 올라감
    A1 <- A2 <- A3 일 때, A3 obj = new A3()에서 A2.test()를 호출한다면 this는 A3, super는 A1을 의미함
    필드 오버라이딩일 때에는 this, super 모두 메서드의 소속을 기준으로 확인함

  * 필드 오버라이딩은 가급적 쓰지 말 것


# 2024-07-02(화)
  ## 특강1
  - https://github.com/codingmonster-tv/Awesome_Resume_Portfolio?tab=readme-ov-file
  - 서류는 웹URL / PDF 둘 다 제출 가능하도록 관리 (구글독스 추천)
  - 서류는 간결한 이름에 pdf로 제출
  - 이력서는 역량 및 소개, 경력, 포트폴리오(프로젝트), 기타 로 구성

  ## 추상클래스 레퍼런스와 메서드 법칙
  - 추상클래스는 인스턴스 생성 불가 / 레퍼런스는 가능
    레퍼런스가 존재한다는 것은 서브클래스의 인스턴스를 받으라는 의미

  ## Template Method Pattern (GoF)
  - 알고리즘의 구조는 그대로 유지하면서 일부 단계는 하위클래스에서 재정의할 수 있도록 하는 패턴
  - 예를 들어, print()라는 메서드는 final로 선언하여 변경을 방지하고,
    내부의 printHeader(), printContent()는 하위클래스에서 정의하도록 설계

    
# 2024-07-03(수)
  ## 정렬
  - 버블 정렬 : 2개씩 비교하며 가장 큰 수부터 우측으로 정렬하는 것
  - 퀵 정렬 : 배열을 부분 배열로 분할하여 정렬한 후 합치는 것

  ## 추상클래스 응용 : 상속
  - 타입을 같게 한다.
    부모클래스의 타입이 같으면, 부모클래스 레퍼런스로 자식클래스 객체를 모두 다룰 수 있다. (다형적 변수)
  - 사용법을 같게 한다.
    자식클래스가 사용하는 메서드가 같으므로, 프로그래밍의 일관성 제공

  ## 추상클래스 응용 : 추상클래스, 추상메서드 도입
  - 상위클래스의 직접 사용을 제한함
    Sorter 상위클래스는 하위클래스에 공통메서드를 정의하기 위해 존재
    일반클래스로 Sorter 정의 시 다른 개발자가 Sorter 인스턴스를 만들 수 있음
    Sorter는 자체기능이 없으므로, 추상클래스로 만들어 직접 사용을 제한
  - 메서드 오버라이딩 강제
    Sorter가 일반클래스이면, 오버라이딩이 강제사항이 아니므로 원하는 메서드가 자식클래스에서 구현이 안 되는 경우가 발생
    추상클래스와 추상메서드를 활용하면 오버라이딩을 강제할 수 있음

  ## 캡슐화
  - 필드를 private으롷 선언하고 getter, setter를 사용하여 접근하면
    원치않는 외부접근을 방지할 수 있고 중간 처리과정을 추가하기 용이함
    추상화 작업 시에도 중간로직을 통해 유효하지 않은 데이터가 들어가는 것을 방지

  * 추상화
  - 사람, 사물, 개념을 데이터화/코드화시키는 작업


# 2024-07-04(목)
  ## 인터페이스
  - 인터페이스를 활용하지 않으면, 유사한 범주의 클래스들이 일관성이 없다.
  - 인터페이스를 활용함으로써 객체 사용 규칙을 정의하고 일관성을 확보할 수 있다.
  - 인터페이스를 구현하는 클래스는 인터페이스에 선언된 메서드를 모두 구현해야 하며,
    구현하지 않을 시 추상클래스가 된다.
  - 인터페이스를 구현한 클래스는 "구현체" 또는 "피호출자",
    이를 이용하는 클래스는 "클라이언트", "사용자", "호출자" 라 칭함
  - 인터페이스 레퍼런스는 해당 규칙에 따라 만든 클래스의 인스턴스를 받는 것
    인터페이스 내의 메서드를 가지고 있어도, 인터페이스를 명시적으로 구현하지 않으면
    인터페이스 레퍼런스로 담을 수 없음
  - 인터페이스의 필드는 모두 public static final로 적용된다. (상수)

  * 대표적인 인터페이스 활용처
  - Servlet 인터페이스 (웹어플리케이션 실행 서버) : 구현체 작성
  - HttpSession 인터페이스 : 클라이언트 작성 (구현체는 Servlet Container에서 제공)

  ## 인터페이스 default, private 메서드
  - 인터페이스 활용 중, 신규 프로젝트를 위해 기존 인터페이스에 새로운 메서드를 추가하면
    신규 프로젝트와 연관된 클래스 뿐 아니라 해당 인터페이스를 사용하는 모든 클래스들이
    새로운 메서드를 추가해야 한다.
  - 이 때 인터페이스에서 default 메서드를 추가하면, 이미 구현된 메서드이기 때문에
    구현클래스에서 따로 구현할 필요가 없다.
  - 여러 default 메서드에서 공통으로 사용할 부분이 있다면, private 메서드를 사용할 수 있다.
  - 구현클래스에서 오버라이딩한 default 메서드 말고 인터페이스의 default 메서드를 사용하려면
    인터페이스.super.default()를 사용해야 한다.

  ## 인터페이스 다중 상속
  - 인터페이스는 다른 인터페이스를 다중 상속받을 수 있다.
    해당 인터페이스를 구현한 클래스는 슈퍼클래스의 인터페이스까지 모두 구현해야 한다.
  - 상속받은 인터페이스에 동일한 명칭의 메서드가 있더라도, 미구현 상태이기 때문에 충돌 X
  - 다만 리턴타입이 다른 경우는 충돌이 발생하여 다중상속 불가 (오버로딩 규칙 미충족)

  ## 인터페이스 다중 구현
  - 여러 인터페이스를 한 클래스에서 구현할 수 있다.
  - 다중 상속과 동일하게, 오버로딩 규칙을 어기는 동일명칭 메서드가 있다면 충돌이 발생한다.
  - 동일명칭의 default 메서드는 다중 구현이 불가하지만, 구현클래스에서 오버라이딩 시 가능

  ## 인터페이스 & 추상클래스
  - 인터페이스에서 추상메서드를 정의하면, 추상클래스가 먼저 인터페이스를 구현하여
    공통되는 메서드를 작성할 수 있음
    실제 클라이언트에서는 추상클래스를 상속받고, 원하는 메서드만 오버라이딩하여 사용 가능
  - 클라이언트가 인터페이스의 모든 메서드를 구현해야 한다는 부담을 덜 수 있음
  - 인터페이스는 객체 사용규칙을 정의 / 추상클래스는 서브클래스에 공통필드/메서드 상속


# 2024-07-05(금)
  ## Iterator
  - ArrayList는 get(), Stack은 pop()을 통해 데이터를 호출
  - 호출하는 메서드가 달라 일관성이 없는데, 이 때 Iterator 구현체를 통해 값을 꺼낼 수 있음
  - Iterator는 hasNext(), next()를 사용해서 데이터 조회


# 2024-07-08(월)
  ## UML / 클래스 다이어그램
  - 상속 (Car <|------ Truck)
  - 연관/Association (Car -> Insurance)
    두 객체가 지속적으로 연결되어 있음을 의미
  - 집합/Aggregation (Car < >------> Navigation)
    부분과 전체 관계
    전체 객체가 소멸하더라도 부분 객체가 독립적으로 존재 가능
    ex- 도서관과 책, 팀과 선수, 자동차와 바퀴
  - 합성/Composition (Car </>------> Engine)
    강하게 결합된 부분과 전체 관계
    전체가 소멸하면 부분도 소멸 (부분은 독립적으로 존재 X)
    ex- 집과 방, 자동차와 엔진
  - 의존/Dependency (Car ......> GasStation)
    한 객체가 다른 객체의 변화에 영향을 받음 / 일시적 관계
    ex- 프린터와 문서 : 인쇄를 위해 일시적으로 문서에 의존
        자동차와 주유소 : 연료 충전 시 일시적으로 주유소 의존
  - 실체화/Realize (Car ......|> DCCombo )
    한 클래스가 하나 이상의 인터페이스에 정의된 메서드를 구현

  ## 실습 프로젝트
  - 메뉴처리 객체(클래스)의 사용규칙 통일
    현재는 User, Project, Board 클래스가 각자의 executeCommand() 사용
    => Interface Command의 execute()를 만들어 객체 사용규칙 통일
       프로그래밍의 일관성 부여
  
  - 리팩토링
    Submenus를 Command 인터페이스 안에 숨긴다.
    상속의 Generalization 적용
    => ArrayList, LinkedList .......> AbstractList
    => User, Project, Board 각 Command의 공통 메서드를 Command 인터페이스로 이동
       일부 공통메서드가 빠지는 HelpCommand를 위해 AbstractCommand 작성
       Template Method 설계 패턴 적용 (super에서 흐름을 정의하고 sub에서 메서드 정의)


# 2024-07-09(화)
  ## 의존성 뒤집기 (Dependency Inversion Principle / DIP)
  - 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 모두 추상화에 의존해야 한다.
  - 추상화는 구체적인 사항에 의존해서는 안 되며, 구체적인 사항이 추상화에 의존해야 한다.
  - 의존객체를 직접 만들지 않고, 외부에서 주입받는 방식

  => Switch가 FluoLamp를 사용할 때, LEDLamp로 바꾸려면 코드를 수정해야 한다. (강한 연결 상태)
  
  => FluoLamp와 LEDLamp를 상위 Lamp를 만들면 다형적 변수를 활용하여 여러 타입을 받을 수 있다.
     하지만 아직까지는 Switch로 조명만 제어 가능하고 다른 제품은 제어가 불가능하다.

  => 만약 Switch가 Lamp 외에도 Fan을 다루기 위해 Device라는 상위 클래스를 만든다면?
     상속관계가 쌓이면서 너무 복잡해지며, Switch로 제어할 수 없는 기기가 포함될 수 있다.
     즉 상속은 "강결합"을 유지하며, 유연성이 부족하다.

  => Switchable 인터페이스를 만들어 각 Lamp, Fan 클래스에서 구현
     즉 FluoLamp, LEDLamp는 Lamp를 상속받으면서 Switchable을 구현
     환풍기, 후드는 Fan을 상속받으면서 Switchable을 구현
     인터페이스를 사용하면 서로 다른 타입의 장치도 스위치로 제어할 수 있다.
     즉 상속보다 인터페이스가 더 유연하다. (약결합 / 느슨한 연결)
     
  => Switch s = new Switch(light)와 같이 외부에서 객체를 주입받으면 유연성 증가
     이유는? 교체 및 테스트가 쉬워진다.

  * SOLID의 D는 Dependency Inversion Principle / DIP 를 가리킨다.
  - Inversion of Control(IoC)에서는 Dependency Injection과 동일

  ## 실습 프로젝트
  - 리팩토링 : Map 컬렉션과 의존성 주입
  - 스택(Stack)과 큐(Queue) 다루기 (menuTitle과 history 구현)

  ## 문자열 연결
  - String 객체는 immutable 이어서 내용 변경 불가
    따라 String 객체에 새로운 문자열을 더하면 새로운 String 객체가 생성됨
    기존 String 객체는 garbage가 됨 / 메모리 낭비
  => mutable 객체인 StringBuffer / StringBuilder 를 사용하여 해결 가능
     StringBuffer 는 Thread-safe하므로 멀티쓰레드에서도 안전하지만 Lock/Unlock에 시간 소요
     StringBuilder 는 Thread-safe를 보장하지 않지만 상대적으로 속도가 빠름
  => 최신 컴파일러는 String으로 연산을 하여도 garbage를 생성하지 않도록 조정함


# 2024-07-10(수)
  ## 실습 프로젝트
  - Iterator 디자인 패턴을 활용하여 목록 조회 기능 캡슐화
  - 특정 클래스에서만 사용하는 의존 객체는 중첩 클래스로 정의
    Node > LinkedList / ListIterator > AbstractList
  - Collection API 사용하기

  ## 설계 패턴 : 어떤 문제에 대한 검증된 해결 방식
  - Factory : 객체 생성 방법이 복잡할 때 -> 생성하는 부분을 캡슐화
  - Abstract Factory : 관련 객체들의 팩토리를 생성하기 위한 인터페이스를 제공
  - Singleton : 단일 인스턴스가 필요할 때
  - Prototype : 기존 객체를 복제하여 새로운 객체를 생성하는 방식
  - Adapter : 상이한 인터페이스간 호환을 제공하는 방식
  - Template : 기본 흐름은 상위에서 정의해두고 세부적인 행위는 하위가 정의

  ## Iterator 설계 패턴
  - List는 입력 순서대로, Set은 hash 값으로 중복 없이, Map은 key, value로 저장
  => 자료구조에 따라 데이터 조회 방법이 상이함 (일관성이 없어 유지보수 어려움)
  => 그래서 Iterator 객체를 통해 캡슐화 및 데이터 조회 통일

  ## 중첩 클래스
  - static nested class를 non-static nested class로 바꾸면 (= inner class)
    컴파일러가 바깥클래스의 인스턴스 주소를 자동으로 받을 수 있게 생성자 생성
  - 바깥클래스의 인스턴스 주소를 사용하고 싶다면, 바깥클래스명.this 로 사용 가능
    중첩클래스 내 동일한 메서드가 없다면, 바깥클래스명.this 생략 가능
  - 메서드 내 local class로 작성하게 되면, non-static nested class와 같이 this를 자동으로 부여
  - 상위클래스나 인터페이스를 통해 익명클래스를 만들 수 있다. (Iterator obj = new Iterator() {})
    익명클래스는 인스턴스를 단 하나만 만들 때 사용

  ## enhanced 'for' loop
  - for( var : arr/Iterable )
  - Iterable 인터페이스를 구현한 것이라면 모두 들어갈 수 있음
    왜냐? 컴파일러가 위 코드를 iterator + while문으로 바꾸기 때문


# 2024-07-11 (목)
  ## 실습 프로젝트
  - Generic을 사용하여 타입을 파라미터로 다루기

  ## Generic
  - 타입 파라미터 <~> : 타입 정보를 받는 변수로 해당 타입의 객체만 허용
    기존 Object를 쓰는 자리에, 특정 타입의 객체만을 허용하겠다는 의미로 사용
  - 관례 : T (Type), E (Element), K (Key), N (Number), V (Value), S/U/V (2nd, 3rd, 4th)
  - ex: class Node<E> {  <- 타입 변수는 대문자로 시작
          E value;
        }
        Node<E> n = new Node<>();  <- 레퍼런스에서 타입을 지정하면 new에서는 생략 가능

  ## 중첩클래스와 쌍방참조
  - 클래스간 쌍방참조는 강결합으로, 유지보수를 어렵게 하고 재사용이 힘듦
    하지만 중첩클래스로 사용하게 되면 쌍방참조가 용이해짐


# 2024-07-12(금)
  ## 로컬 클래스
  - 특정 메서드에서만 사용할 수 있는 클래스
  - 로컬 클래스에서 바깥 메서드의 파라미터 값을 사용한다면
    컴파일러가 자동으로 로컬 변수를 담을 필드와 생성자를 추가한다.
  - 바깥 메서드의 변수를 자유롭게 사용하는 것이 아니라, 복제하는 것
  - this를 생략할 시, 자기 자신부터 바깥 클래스로 순서대로 변수를 찾는다.
  - 로컬 클래스가 참조하는 로컬 변수는 값을 변경하지 말아야 한다.
    왜냐? 내부적으로 final 선언되기 때문에 값이 변경되는 변수는 참조 불가
    로컬 클래스 내에서도 값을 읽을 수만 있고 수정은 불가

  ## functional interface
  - 추상 메서드를 하나만 가지고 있는 인터페이스
  - 이런 메서드는 람다를 활용하여 익명클래스를 만들 수 있다.
    ex- return () -> System.out.println("Hello");

  ## 메서드 레퍼런스 / class::method
  - return My::m1이 있을 때, 컴파일러는 return () -> My.m1()로 바꾼다.
    My 클래스에 구현되어 있는 m1 메서드로 추상 메서드를 구현한다는 의미
    추상메서드와 시그니쳐가 같으면 위와 같이 처리할 수 있다.
    (m1은 static method)
  - 만약 non-static method를 동일하게 활용하고 싶다면 아래 참고
    return new My()::m2;
    =
    return new A() {
      @Override
      public void print() {
        new My().m2();
      }
    }


# 2024-07-15(월)
  ## Composite 패턴
  - App, UserCommand, BoardCommand, ProjectCommand가 있다고 가정했을 때
    Composite 적용 전에는 각 클래스가 모두 메뉴 UI를 다룸
    또한 Command 클래스가 UI + CRUD라는 두가지 역할을 수행
  - SOLID의 S에 따라 메뉴UI를 별도 객체로 분리
  => Composite 패턴은 객체가 트리 구조로 포함 관계일 때 사용하는 패턴
     메뉴, 조직도, 파일 시스템

  ## Command 패턴
  - myapp에서 메뉴처리 기능을 객체화
  - 현재 "회원"의 모든 CRUD가 UserCommand를 사용하는데,
    만약 새 메뉴를 추가한다면 UserCommand를 수정해야 함 (OCP 위반)
    이는 시간 및 비용 증가로 이어짐
  - CRUD 각 메서드를 객체로 전환
    ex: addBoard() -> BoardAddCommand


# 2024-07-16(화)
  ## Lambda
  - functional interface : 추상메서드가 1개인 인터페이스
    구현하는 방법은 아래와 같다.
    1) class MyPlayer implements Player { public void play() { } }
    2) Player obj = new Player() { public void play() { } }    //익명클래스
    3) Player obj = () -> { }    //lambda
  - 3번 예시와 같이, functional interface인 경우 lambda로 구현 가능
  - lambda 컴파일 시, 과거에는 익명클래스로 변환되었으나 이제 메서드로 변환
  - lambda 사용 시 생략 가능한 영역
    1) body가 1줄일 시 중괄호 생략 가능 (return도 반드시 생략)
    2) 파라미터가 1개일 경우 괄호 생략 가능
    3) 파라미터 타입 생략 가능
  * 추상클래스는 lambda의 대상이 아님


# 2024-07-17(수)
  ## Lambda
  - Calculator obj = MyCalculator::plus;
    Calculator라는 functional interface에서 compute() 메서드를 호출하면
    MyCalculator의 plus() 메서드를 호출하도록 하는 코드
  - 규격이 일치해야 가능
    compute(int a, int b) 일 때 plus(int a)는 불가

  ## 생성자 레퍼런스
  - ArrayList::new 하면 ArrayList의 기본 생성자와 동일
  - 람다로도 표현 가능 () -> new ArrayList();


# 2024-07-18(목)
  ## 실습 프로젝트
  - MenuGroup의 경로 계산을 메서드로 분리
  - 파일 입출력 활용 : 바이너리 입출력 적용
    loadData() -> 파일을 읽어 byte[]를 생성하고 이를 객체로 List로 보관
    saveData() -> List에서 객체를 뽑아 byte[]를 생성하고 이를 파일에 저장
  - 파일 형식 (File Format) : 바이너리 데이터를 저장할 때 형식을 정하여 저장
    myapp 예시
    2byte : user 데이터 개수
    2byte : user 데이터 바이트 배열 크기
    4byte : no 필드
    2byte : name 바이트 배열 크기
    *byte : name 바이트
    2byte : email 바이트 배열 크기
    *byte : email 바이트
    2byte : password 바이트 배열 크기
    *byte : password 바이트
    2byte : tel 바이트 배열 크기
    *byte : tel 바이트

  ## 파일 입출력 API
  1) 바이너리 데이터 입출력
  - 문자열은 UTF-8 문자코드 바이트
    정수 및 true/false는 2의 보수 바이트
    실수는 IEEE-754 바이트
  - 전용 편집기로 입출력 수행
  - 메모리를 적게 사용하고 I/O 속도가 빠름
  - PDF, PPT, DOC, GIF, JPEG, MP3, MP4, AVI, WAV, HWP, EXE 등

  2) 텍스트 데이터 입출력
  - 문자열은 UTF-8 문자코드 바이트
    정수, 실수, true/false는 문자열로 만든 후 문자코드 바이트로 변환
    즉 모든 데이터는 문자
  - 텍스트 편집기로 입출력 수행
  - 메모리를 많이 사용하고 I/O 속도가 느림
  - TXT. HTML, CSS, JS, XML, properties, JAVA 등

  ## 사용 가능한 도구
  * ByteArrayInputStream : byte를 읽음

  * ByteArrayOutputStream : 데이터를 byte로 저장
  - write()를 통해 데이터를 넣을 수 있는데, write(int i)를 사용하면 1바이트만 입력됨
    따라 int의 byte 하나하나를 가장 끝자리로 이동해야 함

  * FileInputStreamm : 파일에 저장된 데이털르 읽고 바이트 배열을 반환
  - read() 메서드는 1바이트를 읽어서 4바이트 int 값으로 리턴
  * FileOutputStream : 데이터를 파일로 저장

  ## try with resources
  - try () 안에 closeable한 리소스를 넣으면 try가 종료될 때 자동으로 close() 수행

  ## 비트이동과 연산자 우선순위
  - long target을 대상으로 (int) target >> 56 이 수행할 때
    형변환이 먼저 수행됨에 따라 >> 56은 제대로 수행되지 않음
    target이 int로 바뀌면서 일부가 잘리기 때문
  - 따라 long값을 이동하고 싶을 때에는 (int) (target >> 56)으로 표기해야 한다.


# 2024-07-19(금)
  ## 실습 프로젝트
  - 파일 입출력 활용 : 데코레이터를 이용한 데이터 변환 자동화
  - 파일 입출력 활용 : 객체 직렬화 및 역직렬화
  - 파일 입출력 활용 : 데이터를 CSV 형식의 텍스트로 입출력

  ## Decorator 설계 패턴
  * 기능확장 방법
  1) 상속
  - Printer에 새 기능을 추가하고 싶다면 Printer를 상속하는 Printer2를 추가하여 오버라이딩
    다른 추가 기능이 있다면 Printer2를 상속하는 Printer3를 추가하여 오버라이딩
  - 장점 : OCP를 준수하여 기능을 추가할 수 있음
  - 문제점
    강결합 방식이므로 부모클래스의 특정기능을 제외할 수 없음
    기능 조합에 따라 상속 관계가 복잡해질 수 있음
    상속을 계속하다 보면 기능 중복이 발생할 수 있음

  2) 포함
  - Printer2에서 새 기능을 수행하고 기존 기능은 Printer에 위임
    Printer origin = new Printer(); => origin.print();
  - 문제점
    상속과 같이 기능 중복 발생
    기능을 조합하다 보면 포함 관계가 복잡해질 수 있음

  => Decorator 설계 패턴 (포함 관계 활용)
  - 여러 기능을 상황에 따라 조합할 경우에 적합
  - 기능을 더하거나 빼는 것을 자유롭게 할 수 있다.
  <Interface> Printer를 구현한 <Component> ContentPrinter
  <abstract> PrinterDecorator를 구현한 하위 <Decorator>
  - Decorator 클래스들은 단독으로 사용 불가하며 부품으로만 사용

  ## File I/O API와 Decorator 설계 패턴
  - Abstract class인 InputStream 하위에 Component와 Decorator가 있음
    Components : FileInputStream, ByteArrayInputStream, PipedInputStream, etc
    = Data Sink Stream Classes
    Decorators : FilterInputStream, ObjectInputStream, etc
    = Data Processing Stream Classes

  ## DataInputStream / DataOutputStream
  - 직접 byte 관련 코드를 작성할 필요 없이 DataStream 사용
  - int --writeInmt()--> DataOutputStream --write()--> FileOutputStream  //int -> byte[]
    --readInt()--> DataInputStream --read()--> FileInputStream  //byte[] -> int

  ## 직렬화 / 역직렬화
  - Serialization (=Marshaling) / Deserialization (=Unmarshaling)
  - 직렬화한 byte[] 안에는 인스턴스 필드값과 클래스 정보가 들어있다.
  - 직렬화 대상이 되는 객체는 java.io.Serializable 를 구현해야 한다.
    Serializable은 추상메서드가 따로 없으며, 직렬화를 승인한다는 표시로 사용
  - ObjectInputStream / ObjectOutputStream 사용

  ## CSV 형식으로 입출력 (Comma Separated Value)
  - FileWriter 클래스를 사용해 객체를 문자열로 변환 후 출력 및 저장
  - FileReader, Scanner 클래스를 사용해 파일에서 읽은 후 문자열로 반환 (한줄씩)


# 2024-07-22(월)
  ## 실습 프로젝트
  - 파일 입출력 활용 : JSON 포맷 입출력

  ## JSON
  - Javascript Object Notation 문법을 가져와 만든 포맷
  - https://www.json.org/
  - 객체는 중괄호, 목록은 대괄호로 표기
  - Javascript 문법과 JSON 포맷의 차이점
                    Javascript                        JSON
    문자열          "", '' 문자열 모두 허용           "" 문자열만 허용
    프로퍼티명      그냥 표기하거나 문자열로 표기     문자열로 표기

  - Gson 사용법 : new Gson().toJSON(Object)
    Date 포맷 등을 지정해야 할 경우 GsonBuilder 로 플러그인 장착

  * Gson 객체 생성과 Builder 패턴
  - Builder 패턴 : 건설사가 건물을 지을 때 여러 옵션을 고려하듯이,
                   여러 의존객체(옵션)가 복합적으로 결합된 객체 생성 시 사용하는 설계 패턴
  - SimpleDateFormat과 같은 의존객체를 GsonBuilder에게 주면
    의존객체를 가지는 Gson 객체를 생성 (복합 객체)

  * JSON 목록 데이터에서 Collection 객체 읽기
  - new Gson().fromJSON( JSON 문자열 , Collection Type 정보 ) 활용
  - Collection Type 정보는 TypeToken 익명클래스 활용
    new Gson().fromJson(
          strBuilder.toString(),
          new TypeToken<Collection<Type>>() {
          });
  - TypeToken.getParameterized(Collection.class, Type.class)로도 사용 가능

  ## Method Chaining
  - 예시로 setter 메서드가 원래는 void를 반환하는데,
    이를 객체 자신을 반환하게 함으로써 메서드를 이어 사용할 수 있게 하는 것
    public Member setNo();
    new Member()
      .setNo(100)
      .setName("aa")
      .setworking(true);

  ## Generic
  - 타입이 결정되지 않은 레퍼런스는 인스턴스에 제약이 생긴다.
  - 예를 들어, ArrayList<? extends C> 또는 ArrayList<? super C> 로 선언한 레퍼런스는
    add()와 같이 내부에서 타입 검사를 해야 하는 메서드를 사용할 때
    ?의 값을 컴파일러가 확신할 수 없기 때문에 유효성이 검증되지 않은 값은 오류가 발생한다.


# 2024-07-23(화)
  ## 파일 입출력 정리
  1) Byte Stream Class : FileInputStream / FileOutputStream
  - byte를 입출력하며, InputStream / OutputStream의 서브클래스이다.
  
  FileOutputStream
  - Decorator 패턴의 component에 해당
  - 데이터를 write()로 받아 byte로 출력
  - write(int) : 1바이트로 출력
  - write(byte[]) : byte[]로 출력
  - write(byte[], offset, len) : 출력수를 조절하여 byte[]로 출력
  - 파일 저장 경로는 JVM 작업 디렉토리 기준
    해당 경로에 동일명 파일이 있으면 기존 파일은 삭제
    (유지하고자 할 때에는 별도 옵션 필요)
  - 사용 후 close()로 자원 반환

  FileInputStream
  - read() : 1 byte를 읽어 4 byte int 값으로 반환
  - read(byte[]) : 배열 크기만큼 읽어 배열로 반환
  - read(byte[], offset, len) : 특정 위치에서 읽어 배열로 반환
    read(buf, 10, 40) : buf에서 40개를 읽어 10번부터 채움
  
  String 객체와 byte
  - String 객체를 생성하면 UTF-16BE (ucs2) 방식으로 저장
  - String 객체에 getBytes()를 호출하면 JVM -> OS 순의 기본 문자집합으로 인코딩
    JVM은 file.encoding 값에 따라, Windows는 MS949, Linux/Unix/Mac은 UTF-8

  2) Character Stream Class : FileReader / FileWriter
  - 문자 코드를 입출력하며, Reader / Writer의 서브클래스이다.
  - 주어진 파일이 텍스트 파일이라고 간주하고 변환하기 때문에,
    이미지 등 텍스트가 아닌 파일에 사용하지 않도록 주의해야 한다.

  FileWriter
  - write()로 UCS2를 문자코드로 변환하여 입력
    int, char[], String 모두 문자코드 바이트 배열로 변환
    UCS2 -> 문자코드 / 문자코드는 JVM, OS 기준

  FileReader
  - read()로 문자코드를 UCS2로 바꾸어 출력

  3) 버퍼 활용
  버퍼 사용 전
  - in.read() -> 읽기 시간 = seek time + transfer time
    seek time : 외부메모리에서 읽을 데이터를 찾는 시간
    transfer time : 찾은 데이터를 RAM으로 이동시키는 시간

    버퍼를 사용하기 전에는 매번 in.read()로 읽어야 하기 때문에
    읽을 때마다 seek time과 transfer time이 소요된다.

  버퍼 사용 후
  - 한 번의 in.read()로 많은 용량을 읽어 seek time 단축
  
  * 버퍼와 서버 어플리케이션
  - 일반 PC인 경우 전송 용량을 1MB로 하더라도 무리가 없음 (독점 사용)
  - 서버는 동시사용자의 수가 많아 1MB 설정 시 RAM 크기 초과
  - 따라 실무에서는 대개 8KB, 16KB 정도로 속도 제한

  4) Buffered Stream Class : BufferedFileInputStream / BufferedFileOutputStream
  - Buffered Stream 이 read()를 수행해서 배열에 담아둔 후,
    요청이 있을 시 하나씩 반환
  - buffer는 특정 용량이 차면 데이터를 넘겨주는 식이기 때문에,
    마지막에 남은 데이터도 넘기기 위해 flush() 호출


# 2024-07-24(수)
  ## 실습 프로젝트
  - Apache POI를 활용하여 데이터를 엑셀로 입출력

  ## 파일 입출력
  * 복습
  - 버퍼를 사용하면 입출력 속도가 빨라진다.
    이유는? File Access 횟수를 줄이기 때문
    횟수를 줄인다는 것은 seek time이 줄어든다는 의미
    (seek time이 상대적으로 transfer time보다 길다.)
  - FileInputStream이 파일을 읽으면  //read(byte[])
    BufferedInputStream이 byte[]에 담고  //read()  
    DataInputStream이 byte[]를 primitive data type으로 변환  //readInt()
  - JVM은 직접 파일을 읽을 수 없고, 각 OS에서 제공하는 read()를 사용

  ## Serializable
  - ObjectOutputStream, ObjectInputStream은 Serializable을 구현해야 함
    writeObject(), readObject()로 객체를 간단히 읽고 쓸 수 있지만
    다른 프로그래밍 언어에서 해당 데이터를 활용할 수 없음

  * serialVersionUID : 클래스 버전에 대한 값
  - 개발자가 지정하지 않으면 자동 생성됨
  - 클래스를 변경하면 (필드/메서드 추가/삭제) 버전 값이 새로 생성됨
  - ObjectStream으로 저장 시 클래스 버전 값이 함께 저장되며
    읽을 때 클래스 정보에서 버전 값을 검증한 후 인스턴스 및 필드값 설정

  * transient
  - Serialize 대상에서 제외하는 명령어
  - sum, avg 같이 다른 필드값을 조합하여 산출하는 필드에 사용 가능

  ## 파일 입출력 예외처리
  - 파일 입출력 시 FileNotFoundException, IOException 예외처리 필요
    FileNotFoundException이 IOException 하위이기 때문에 먼저 처리해야 함
  - close() 사용 시에도 예외처리 필요

  ## Base64
  - Encoder와 Decoder를 통해 byte[]를 Base64로 변환/복원할 수 있다.
    파일에서 byte[]를 받아 Base64.getEncoder()를 통해 Base64 텍스트로 변환
    Base64.getDecoder에서 Base64 텍스트를 받아 byte[]로 복원

  ## Apache POI Library
  - MS 파일을 읽고 쓸 수 있는 라이브러리
  - https://poi.apache.org/
  - HSSF : 엑셀 97 (.xls)
  - XSSF : 엑셀 2007 (.xlsx)
  - Workbook, Sheet, Row, Cell 을 활용하여 입출력


# 2024-07-25(목)
  ## 실습 프로젝트
  - DAO 필요성 이해하기 : 데이터 컬렉션을 List에서 Map으로 교체
    현재 Command 사용 시, 컬렉션을 변경해야 한다면 각 Command의 코드를 모두 변경해야 함
  - DAO를 통해 데이터 접근 로직을 캡슐화
    

  ## 파일 입출력
  - Data Sink Stream : 데이터를 최종 저장하거나 전송하는 목적지 (FileOutputStream)
  - Data Processing Stream : 데이터의 실시간 처리 및 변환 담당 (ObjectOutputStream)

  ## DAO
  - Data Access Object
  - 데이터 접근 로직을 별도의 클래스로 분리하여 캡슐화
    boardList와 BoardCommand 사이에 BoardDao 클래스를 추가
    List를 Map으로 바꾸더라도 BoardDao만 변경하면 된다.
  - 하지만 SOLID의 OCP는 불충족 / BoardDao는 변경되기 때문
    따라 BoardDao를 인터페이스로 변경
    그 하위에 MapBoardDao, ListBoardDao를 생성


# 2024-07-26(금)
  ## 실습 프로젝트
  - DAO를 통해 데이터 접근 로직을 캡슐화
    Map에서 List로 변환 테스트
  - Observer 패턴 적용

  ## Observer Pattern
  - Listener / Observer를 등록해두면, App.의 상태가 변경될 때 알림을 받음
    프로그래밍 세계에서 알림을 준다는 것은 메서드를 호출하는 것
  - Class App : addApplicationListener(), removeApplicationListener()
    Interface ApplicationListener : onStartup(), onShutdown()
  - 통상 listener라 불리면 observer pattern을 적용한 것


# 2024-07-29(월)
  ## 실습 프로젝트
  - 애플리케이션 간에 데이터 공유 : Client/Server 아키텍처로 전환
    1) 파일 직접 공유 (여러 애플리케이션이 동시에 접근할 수 없고, 파일을 덮어쓸 가능성이 있음)
    2) 파일 간접 공유 (데이터 입출력을 관리할 프로그램을 별도로 두고, 해당 프로그램을 통해 입출력)
    2안으로 가기 위해 기존 myapp을 둘로 분할
    app-client : UI 및 업무로직 처리
    app-server : 데이터 및 파일입출력 처리
    =  CS Architecture / CS Application

  * Protocol (데이터 송수신 규칙)
  - Client는 데이터명(users), 작업명령(insert, list, get, update, delete), 데이터를 전송
  - Server는 응답상태(success, failure), 응답데이터를 전송

  * Sequence Diagram
  - 시간에 따라 객체의 실행 흐름을 표현
  - ClientApp -> 연결 -> 요청 -> ServerApp -> service() -> UserDaoSkel -> call -> UserDao
    -> 작업 수행 -> return -> 응답

  * 라이브러리 프로젝트
  - app-server와 app-client의 공통 코드를 app-common 프로젝트로 관리
  - vo 객체와 net 관련 객체를 공유

  ## Client/Server Architecture
  - Client는 UI와 업무 로직을 처리하며, 데이터 처리가 필요할 시 Server를 호출
  - Server는 Client로부터 처리 의뢰가 들어오면 데이터 처리 및 입출력을 수행

  ## Networking API
  - Client : Socket class로 상대편과의 접속 및 데이터 I/O 관리
  - Server : ServerSocket class로 Client와의 연결 관리
             Socket class로 Client쪽 Socket과 통신
  - Socket class 내부에서는 OutputStream, InputStream으로 입출력 수행

  * ServerSocket
  - new ServerSocket([포트번호], [대기열크기])
  - 서버측 포트번호는 직접 지정하며, 클라이언트 포트번호는 OS가 지정
  - accept() : 대기열에 클라이언트가 등록되는 순간 즉시 소켓 연결

  * Socket
  - new Socket([IP주소], [포트번호])

  ## 라이브러리 프로젝트
  - 프로젝트간 코드 공유

  ## Skeleton과 Stub
  - Object Request Broker (ORB) : 객체 요청과 관련하여 중개 역할을 수행
    = Proxy 객체
  - 원격 객체 : 다른 프로세스가 만든 객체
  - Skeleton : 서버 측에서 클라이언트로부터 온 요청을 실제 원격 객체로 전달하는 역할
  - Stub : 클라이언트 측에 존재하는 객체로, 원격 객체의 프록시 역할
    = 실제 작업은 Stub이 서버와 통신하고 서버에서 작업을 수행하지만,
      클라이언트는 Stub이 마치 원격 객체인 것처럼 사용
    => 따라 Stub은 원격 객체처럼 사용할 수 있도록 메서드를 구현
  - 서버측 개발자가 Stub과 Skeleton을 모두 작성


# 2024-07-30(화)
  ## 실습 프로젝트
  - 여러 클라이언트 요청을 순차 처리하기 : Stateful vs Stateless

  ## Adapter vs Proxy
  - Adapter
    Printer2 인터페이스를 사용하는 Client가 Printer 인터페이스도 쓰고 싶다면
    Printer와 포함 관계에 있는 Printer2 구현 클래스 Adapter를 만들어 사용
  - Proxy
    원격 객체 Printer를 사용하려면 직접사용이 불가하여 통신을 이용해야 한다.
    따라 ProxyPrinter를 사용하고, 해당 클래스가 원격 객체와 통신하도록 한다.
    Adapter와의 차이는, Proxy의 경우 원격 객체와 동일한 것처럼 보여야하기에
    같은 Printer 인터페이스를 구현하도록 작성한다.

  ## 원격 객체 (Remote Object)
  - 다른 JVM에서 만든 객체 (= 다른 프로세스에서 만든 객체)
    통신 없이는 사용이 불가
  - 따라 ORB, Object Request Broker를 통해 사용
    Client가 Stub을 호출하면 Stub이 Server의 Skeleton과 통신하여 요청하고,
    Skeleton이 원격 객체를 호출해 작업을 수행한 후 응답
  - Server 개발자가 Skeleton, Stub 작성

  ## 통신 방식
  - Connection-oriented : 연결 후 통신 (TCP / FTP, Telnet, SSH 등)
    1) Stateful
       클라이언트와 서버간 연결 상태 정보를 저장하는 방식
       한번 연결한 후 여러번 요청/응답을 수행
       기존 작업 결과를 바탕으로 이어지는 작업을 처리할 때 적합
       요청/응답 속도는 상대적으로 빠름 / 적은 수의 연결 (메모리에 연결 유지)
       ex : 전화상담, FTP, SSH 등
    2) Stateless
       서버가 이전 요청 상태를 유지하지 않는 방식
       한번 연결한 후 한번 요청/응답 수행
       요청마다 독립적으로 수행해야 하는 작업을 처리할 때 적합
       요청/응답 속도는 상대적으로 느림 / 많은 수의 연결
       ex : 114, HTTP1, HTTP2, 메신저 등
  - Connectionless : 비연결성 통신 (UDP / ping, HTTP3 등)

  ## Socket 주소
  - socket.getRemoteAddress() 호출 시 SocketAddress 객체 리턴
  - SocketAddress는 추상클래스이기 때문에 실제로는
    InetSocketAddress, UnixDomainSocketAddress 객체가 리턴

  ## Domain Name & IP Address
  - new Socket([도메인주소], [포트번호])를 실행하면
    1) OS에 설정된 DNS 서버에 문의
       => [도메인주소]의 DNS 서버 주소 리턴
    2) [도메인주소] DNS 서버에 "www" 이름의 IP 주소 문의
       => www + [도메인주소]의 IP 주소 리턴


# 2024-07-31(수)
  ## 네트워킹
  - 클라이언트에서 write() 호출 시, 출력할 대상을 클라이언트의 NIC 메모리로 보내고
    이를 서버 NIC로 전달한다. 이 때 서버가 read()를 호출하는 것은 상관없이 리턴한다.
  - byteStream은 flush()를 호출하지 않아도 데이터가 전달된다.
    buffer를 사용할 때에는 flush()를 호출해야 한다.
    Decorator를 사용할 때에는 가능한 flush()를 호출하라.
  - Stream으로 끝나면 byte stream, reader/writer로 끝나면 character stream
  - socket으로 Reader를 사용하고 싶다면, adapter인 InputStreamReader를 사용한다.
  - Authentication (인증) : 아이디, 암호 유효성 검사
    Authorization (권한) : 인증받은 사용자의 권한을 확인
  - 비연결형 네트워킹은 DatagramSocket, DatagramPacket 사용

  ## Multi Thread
  - Thread : 실행 흐름
  - CPU가 각 스레드를 순차, 반복적으로 실행
  - stateful 방식도 멀티스레드를 사용함으로써 stateless와 유사하게 작동할 수 있음
  - stateful, stateless의 고질적인 문제점?
    요청 처리에 시간이 오래 걸리면 그 시간만큼 대기해야 한다.
    => Multi Thread를 사용하여 병행 처리함으로써 이 문제를 해결할 수 있다.

  ## HTTP (Hyper Text Transfer Protocol)
  - Client
    GET /a/b/x.html HTTP/1.1
    Host: www.naver.com
    ...
  - Server
    HTTP/1.1 200 OK
    Date : ...

  ## URL
  - Uniform Resource Identifier
  - 두 종류로 구분
    URL : Uniform Resource Locator
          http://www.naver.com/news/a.html
    URN : Uniform Resource Name
          urn:isbn:045103050


# 2024-08-01(목)
  ## 실습 프로젝트
  - 다중 클라이언트 요청 처리


# 2024-08-02(금)
  ## 멀티 태스킹
  - 한 개의 CPU로 여러 작업을 병행 처리
    프로세스 : 실행 파일을 메모리에 로딩하여 실행한 상태
    L1 cache : 8~64KB, CPU가 가장 빠르게 접근하며 데이터를 못 찾으면 L2로 이동
    L2 cache : L1보다 속도가 느리지만 더 많은 용량 제공
    L3 cache : 멀티코어 CPU에서 공용으로 사용
    HDD/SSD -> RAM -> CPU

  * context-switching
  - 다른 프로세스로 이동하기 전, 실행 위치를 저장해야 한다.
    이 때 실행 정보를 context라 칭한다.
  - 이 실행정보를 교환하는 과정을 context-switching이라 한다.

  * CPU Scheduling Algorithm
  1) Round-Robin : CPU 사용 시간을 골고루 분배하는 방식
  2) Priority + Aging 기법 : 우선순위와 지연된 시간을 모두 고려하는 방식

  * Multi Processing
  - 별도 실행으로 병행으로 수행해야 할 작업이 있다면 프로세스를 fork
  - fork 시 프로세스의 명령코드와 Heap 메모리도 복제되기에 자원 낭비가 발생

  * Multi Threading
  - 프로세스를 실행하는 중간에 새로운 Thread를 실행
  - 스레드는 프로세스 코드와 Heap 메모리를 공유하여 자원 절약

  ## 자바와 멀티스레딩
  - <Process>JVM -> <Thread>main -> main() -> <Thread>child -> run()

  ## 자바 스레드와 OS
  - new Thread() -> OS에게 요청 -> OS가 스레드 생성 -> new Thread()와 연결
    즉 자바의 스레드는 OS의 스레드를 가리킨다.
    실행 방식은 OS 스레드 스케쥴링에 종속된다.
    => OS의 기능을 수행하면서 스레드를 관리하기에 메모리 사용이 높아지고 속도가 느리다.
    => 따라 가상스레드라는 개념이 등장한다.
  - 가상스레드란? JVM이 직접 관리하는 스레드
    OS에 종속되지 않아 메모리가 적게 들고 자유로움

  ## 스레드 생명주기
  - running : CPU를 사용 중이거나 사용하기 위해 대기하고 있는 상태 (CPU Racing 상태)
  - not runnable : CPU를 받지 않는 상태 ( sleep(), wait() )
                   sleep()이 timeout되거나 notify()를 호출하면 running으로 변경
  - dead : run() 실행이 종료된 상태 / dead -> running은 불가
           실행이 종료된 스레드는 재사용 불가


# 2024-08-05(월)
  ## DBMS 도입
  - 데이터베이스: 여러 사람이 공유하는 데이터 집합
    검색, 갱신이 용이하고 실시간 접근이 가능
    일관성, 무경설, 보안성


# 2024-08-06(화)
  ## DBMS
  - 로그인 : mysql -u [아이디] -p
  - 사용자 생성 : CREATE USER [아이디]@[호스트] identified by [비밀번호];
    호스트는 도메인, IP주소, 또는 % (외부 모든 서버)
    호스트가 달라지면 아이디는 동일해도 상관 없다.
  - 사용자 삭제 : DROP USER [아이디]@[호스트];
  - DB 생성
    CREATE DATABASE [DB명]
    DEFAULT CHARACTER SET UTF8
    DEFAULT COLLATE utf8_general_ci;
    utf_general_ci? 문자 정렬 및 비교 방식
  - DB 삭제 : DROP DATABASE [DB명]
  - 권한 부여 : GRANT [권한범위] ON [DB명].[테이블명] TO [아이디]@[호스트];

  ## SQL
  - Structured Query Language
    DDL (Data Definition Language) : CREATE, DROP, ALTER
    DML (Data Manipulation Language) : INSERT, UPDATE, DELETE
    DQL (Data Query Language) : SELECT

  ## 인덱스
  - 컬럼에 저장된 문자열을 알파벳순/역순으로 정렬한다.
  - 인덱스로 지정된 컬럼의 값이 추가/변경/삭제 될 때 인덱스 정보도 갱신한다.
  - 따라서 입력/변경/삭제가 자주 발생하는 테이블에 대해 인덱스 컬럼을 지정하면,
    입력/변경/삭제 시 인덱스 정보를 갱신해야 하기 때문에 속도가 느려지는 문제가 있다.
  - 대신 조회 속도는 빠르다.

  * 중간에 특정 단어가 포함된 목록을 찾을 때에는 검색엔진 솔루션 사용
    예 : 솔트룩스, 와이즈넛, ElasticSearch

  ## Projection vs Selection
  - Projection : 결과 데이터로 추출할 컬럼 선택
    select "no, name, class" from ...
  - Selection : 결과 데이터의 선택 조건
    where "working = 'Y'"


# 2024-08-08(목)
  ## Row & Column
  - row = record = tuple
  - column = field = attribute

  ## DML
  - Data Manipulation Language
  - 오라클 기준 등록, 변경, 삭제를 다루는 문법

  ## 파일과 변경/삭제
  - 파일 데이터 변경 시, 기존 값이 저장된 부분을 새로운 값으로 대체
  - 파일 데이터 삭제 시, 기존 값이 저장된 부분을 0으로 초기화
    데이터를 제거하려면 뒤에 있는 데이터를 모두 앞으로 이동시켜야 하기에
    시간 소요를 피하고자 그냥 0으로 초기화한다.

  ## autocommit
  - 대상 : insert, update, delete와 같은 데이터 조작어
  - SQL이 실행되면 DBMS에 즉시 적용되어 되돌릴 수 없다.
  - autocommit을 해제하면, SQL 실행 결과를 별도 버퍼에 임시 저장
    이후 commit/rollback에 따라 DBMS에 적용하거나 되돌린다.
  - 이 때 버퍼는 해당 스레드의 버퍼이기 때문에
    새로운 클라이언트로 접속 시 임시데이터는 조회되지 않는다.
  - 데이터를 조회하면 마지막으로 커밋된 DBMS 데이터를 버퍼에 보관
    따라 이후 새로 추가된 데이터는 버퍼를 비우기 전에 조회 불가
    즉 autocommit이 해제된 상태에서는 조회데이터가 실제와 다를 수 있다.

  * 트랜잭션 (Transaction)
  - 여러 개의 작업을 한 단위로 묶은 것

  ## 날짜 다루기
  - date_add(날짜데이터, interval 값 단위);
  - date_sub(날짜데이터, interval 값 단위);


# 2024-08-09(금)
  ## DB 프로그래밍
  1) Vendor API = Naive API : DB 제조사에서 제공하는 API
     [ Java App -> Vendor API -> DB ]
     DBMS마다 API 사용법이 다르다는 문제점이 있음

  2) ODBC API (Open Database Connectivity)
     [ Java App -> ODBC Driver -> Vendor API -> DB ]
     MS에서 Vendor API 통일을 제안
     ODBC API는 규격을 정의, 그 규격에 따라 ODBC Driver로 함수 정의
     즉 서로 다른 DBMS를 하나의 프로그래밍으로 사용 가능
     단 Driver가 ODBC의 모든 함수를 구현하지는 않을 수 있음
     Excel은 API를 거치지 않고 Driver가 바로 소통

  3) JDBC API (Java Database Connectivity)
     자바 어플리케이션에서 사용할 수 있는 DB 접근 API
     자바 개발자가 OS나 DBMS에 관계없이 일관된 방법으로 프로그래밍할 수 있다.

     Type 1 : ODBC-JDBC Bridge Driver
     [ Java App -> JDBC Driver -> ODBC Driver -> Vendor API -> DB ]
     JRE에 기본 포함되며 OS에 종속적이다.
     자바 앱에서 JDBC Driver를 호출하면 각 DB별 ODBC Driver를 호출
     즉 ODBC Driver가 설치되어야 하며, 실행 속도가 느리다.
     Adapter Pattern 적용

     Type 2 : Native API Call Driver
     [ Java App -> Vendor별 JDBC Driver -> Vendor API -> DB ]
     JDBC API 규격에 맞춰 각 Vendor에서 Driver를 구현
     JRE에 기본 포함되어 있지 않아 별도 다운로드 필요
     직접 Native API를 호출하므로 Native API 설치 필요하며 OS 종속적
     Excel은 Type2 Driver가 없어 사용 불가

     Type 3 : Middleware Driver
     [ Java App -> 중계서버 Driver -> 중계서버 -> Vendor별 JDBC Driver -> DB ]
     Type 1, Type 2는 DBMS 접속을 위해 전용 Client API를 설치해야 한다.
     만약 DBMS를 교체한다면 모든 Client API를 재설치해야 한다.
     이를 해결하기 위해 App과 DBMS 사이에 중계서버 Middleware를 둔다.
     Proxy Pattern 적용 (Client의 Driver가 마치 Vendor별 Driver처럼 동작)
     => DBMS를 교체하더라도 Client는 영향이 없다.
        DBMS 교체 시 중계서버의 Vendor별 Driver만 변경하면 된다.
        다만 실행속도가 느리며 비용이 발생한다.

     Type 4 : Network Protocol Driver
     [ Java App -> Vendor별 JDBC Driver -> DB ]
     DBMS용 다운로드 필요하며, Driver가 각 DBMS와 직접 통신

  ## JDBC API 사용법
  1) DBMS에 연결
  - DriverManager에게 Connection 요청
    MySQL JDBC Driver를 사용하여 Connection 구현객체 반환
    getConnection(url, username, password)
      url : jdbc:mysql://host:port/db
  2) SQL 전달 객체 준비
  - Connection 객체의 createStatement 사용하여 Statement 객체 반환
  3) SQL 실행
  - executeUpdate() : insert, update, delete에 사용하며 행 수 반환
  - executeQuery() : select에 사용하며 ResultSet 객체 반환 


# 2024-08-12(월)
  ## DBMS datetime 필드
  - getDate()로 호출하면 java.sql.Date() 객체 리턴
  - getTimestamp()로 호출하면 java.sql.Timestamp 객체 리턴
  - java.util.Date를 사용하면 위 2가지를 모두 받을 수 있음

  ## Foreign key